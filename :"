public interface ILinkedList {
	public void add(int index, int element);
	
	public void add(int element);

	public int get(int index);
	
	public void set(int index, int element);
	
	public void clear();
	
	public boolean isEmpty();
	
	public void remove(int index);
	
	public int size();
	
	public ILinkedList sublist(int fromIndex, int toIndex);
	
	public boolean contains(int o);


}
///////////////////////
//////////////
/////////////


public class sigleList implements ILinkedList {

 
	Node head;
	    static class Node { 
	  
	        int data; 
	        Node next; 
	  
	        // Constructor 
	        Node(int d) 
	        { 
	            data = d; 
	            next = null; 
	        } 
	    }
	
	
	public void add(int index, int element){
		Node n=new Node(element);
		if (head==null)
			head=n;
		else {
		
		Node current=head;
		for (int i=0 ; i<= index-2;i++)
			current=current.next;
		n.next=current.next;
		current.next=n;
		
	
	}
	}
	public void add(int element) {
		Node n=new Node(element);
		if (head==null)
			head=n;
		else {
		Node current;
		current = head;
		while (current.next!=null) 
			current=current.next;
		current.next = n;
		n.next = null;	
	}
	}
	public int get(int index) {
		Node current=head;
		for (int i=0;i<index;i++) {
			current=current.next;
		}
		return current.data;		
	}
	public void set(int index, int element) {
		Node current=head; 
		for (int i=0;i<index;i++) {
			current=current.next;
			
		}
		current.data=element;
	}
	public void clear() {
		  // not sure!
		head=null;
	}
	public boolean isEmpty() {
		return (head==null);
		
			
	}
	public void remove(int index) {
		Node current=head;
		if (index==0) { head=head.next; return;}
		if (index+1>size()) { System.out.println("Out Of Size");return; }
		
		for (int i=0;i<=index-2;i++)
			current=current.next;
		Node n=current.next;
		current.next=n.next;
		
	}
	public int size() {
		Node current=head; int size=0;
		while (current!=null) {
			size++; current=current.next;}
		return size;
		
			
	}
	
	public sigleList sublist(int fromIndex, int toIndex) {
		Node current=head;
		for (int i=0;i<=fromIndex-1;i++)
			current=current.next;
		sigleList l2=new sigleList();
		l2.head=current; 
		for (int i=fromIndex;i<=toIndex-1;i++)
			current=current.next;
	current.next=null;
		
		
		l2.print();
		return l2;
		
	} 
	public boolean contains(int o) {
		Node current=head;
		while (current!=null) {
			if (current.data==o) return true;
			current=current.next;
		}
		return false;
		
	}
	public void print () {
		Node current=head;
		while (current!=null) {
			System.out.println(current.data+",");
			current=current.next;
		}
	}
	
	
	



}
///////////////////////
///////////////////////
//////////////////////////
public class doubleList implements ILinkedList {
	Node head;
    static class Node { 
  
        int data; 
        Node next;
        Node prev;
  
        // Constructor 
        Node(int d) 
        { 
            data = d; 
            next = null; 
           
        } 
    }
    public void add(int element) {
    	Node n=new Node(element);
		if (head==null)
			head=n;
		else {
		Node current;
		current = head;
		while (current.next!=null) 
			current=current.next;
		current.next = n;
		n.next = null;	
		n.prev=current;
	}
    	
    }
    public void add(int index, int element){
		Node n=new Node(element);
		if (head==null)
			head=n;
		else {
		
		Node current=head;
		for (int i=0 ; i<= index-2;i++)
			current=current.next;
		n.next=current.next;
		n.prev=current;
		current.next=n;
		
	
	}
	}
    public int get(int index) {
		Node current=head;
		for (int i=0;i<index;i++) {
			current=current.next;
		}
		return current.data;		
	}
    public void set(int index, int element) {
		Node current=head; 
		for (int i=0;i<index;i++) {
			current=current.next;
			
		}
		current.data=element;
	}
    public void clear() {
		  // not sure!
		head=null;
	}
    public boolean isEmpty() {
		return (head==null);
		
			
	}
    public void remove(int index) {
		Node current=head;
		if (index==0) { head=head.next; return;}
		if (index+1>size()) { System.out.println("Out Of Size");return; }
		
		for (int i=0;i<=index-2;i++)
			current=current.next;
		Node n=current.next;
		current.next=n.next;
		Node x=n.next;
		x.prev=current;
		
	}
    public int size() {
		Node current=head; int size=0;
		while (current!=null) {
			size++; current=current.next;}
		return size;
		
			
	}
    public doubleList sublist(int fromIndex, int toIndex) {
		Node current=head;
		for (int i=0;i<=fromIndex-1;i++)
			current=current.next;
		doubleList l2=new doubleList();
		l2.head=current; 
		for (int i=fromIndex;i<=toIndex-1;i++)
			current=current.next;
	current.next=null;
		
		
		l2.print();
		return l2;
		
	}
    public boolean contains(int o) {
		Node current=head;
		while (current!=null) {
			if (current.data==o) return true;
			current=current.next;
		}
		return false;
		
	}
    public void print () {
		Node current=head;
		while (current!=null) {
			System.out.println(current.data+",");
			current=current.next;
		}
	}
    


}

/////////////////////////
////////////////////
System.out.println("Insert the variable name: A, B or C");	
		 Scanner scan = new Scanner(System.in); 
		 char value = scan.next().charAt(0);
		 System.out.println("Insert the polynomial terms in the form:\n(coeff1, exponent1), (coeff2, exponent2), ..");
		    String s = scan.next();
		    int c=0; int tS=0; int tSS=0;
		    char[] a=s.toCharArray();
		    
		    int[][] terms=new int[a.length][2];
		    for (int i=0;i<a.length;i++) {
		    	if (a[i]!='('&&a[i]!=')'&&a[i]!=',') {
		    		if (c%2==0) terms[tS++][0]=Character.getNumericValue(a[i]);
		    		else    terms[tSS++][1]=Character.getNumericValue(a[i]);
		    		c++;
		    	}

